/***************************************
				|GROUP-37|
  Latika Agrawal       -   2019A7PS0433P
  Surya Prakash        -   2019A7PS0057P
  Surya Rathi          -   2019A7PS0128P
  Saransh Goel         -   2019A7PS0988P
  Mobeen Parwaiz       -   2019A7PS0093P
*****************************************/

#include "driver.h"
#include "lexer.h"
#include "parser.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void store_error(int line_no, int type, char* message) {
	char* type_err;

	if (line_no == -1)
	{
		printf("%s \n", message);
		return;
	}

	switch (type)
	{
	case LEXICAL_ERROR:
		type_err = "LEXICAL ERROR";
		snprintf(lexical_errors[lex_err_num++], MAX_ERROR_STRING_LENGTH, "%d : %s | " "%s\n", line_no, type_err, message);
		break;

	case SYNTACTIC_ERROR:
		type_err = "SYNTACTIC ERROR";
		snprintf(syntactic_errors[syn_err_num++], MAX_ERROR_STRING_LENGTH, "%d : %s | %s\n", line_no, type_err, message);
		break;

	case INTERNAL_ERROR:
		type_err = "INTERNAL ERROR";
		break;
	}
}

void print_errors()
{
	if (lex_err_num != 0)
	{
		printf("\t\tLEXICAL ERRORS :\n");
		for (int i = 0; i < lex_err_num; i++)
		{
			printf("%s\n", lexical_errors[i]);
		}
		return;
	}

	if (syn_err_num != 0)
	{
		printf("\t\tSYMANTIC ERRORS :\n");
		for (int i = 0; i < syn_err_num; i++)
		{
			printf("%s\n", syntactic_errors[i]);
		}
		return;
	}
}

/**
 * Prints menu options
 */
void print_menu() {
	printf("LEVEL 4: Symbol table/type Checking/Semantic rules modules work/ handled static and dynamic arrays in type checking and code generation\n");
	printf("\t\t Press the option for the defined task\n");
	printf("-----------------------------------------------------------------\n");
	printf("0. Exit\n");
	printf("1. Print tokens generated by lexer\n");
	printf("2. Print parse tree for the program\n");
	printf("3. Memory used\n");
	printf("-----------------------------------------------------------------\n");
	printf("Enter your choice:  ");
}

/**
 * @brief Read tokens from the file and make a mapping array which maps
 * enumerated tokens to strings
 *
 */
void populate_terminal_string() {

	FILE* file = fopen("tokens.txt", "r");
	fseek(file, 0, SEEK_END);
	int length = ftell(file);
	fseek(file, 0, SEEK_SET);

	char* t_file = malloc(sizeof(char) * (length + 1));
	if (t_file == NULL) {
		perror("terminal_string filling failed\n");
		exit(1);
	}

	fread(t_file, sizeof(char), length, file);
	t_file[length] = '\0';
	fclose(file);

	char* tk_read = NULL;
	int i;
	tk_read = strtok(t_file, ", \n");

	for (i = 0; tk_read != NULL; i++) {
		strncpy(terminal_string[i], tk_read, MAX_SYMBOL_LENGTH);
		tk_read = strtok(NULL, ", \n");
	}

	free(t_file);
}

/**
 * @brief inserts all non-terminal strings in an array, which is used for
 * mapping enumerated non-terminals to corresponding string values
 *
 */
void populate_non_terminal_string() {
	FILE* file = fopen("non_terminals.txt", "r");

	fseek(file, 0, SEEK_END);
	int length = ftell(file);
	fseek(file, 0, SEEK_SET);

	char* nt_file = malloc(sizeof(char) * (length + 1));

	if (nt_file == NULL) {
		store_error(-1, INTERNAL_ERROR, "Parser init failed");
		exit(1);
	}

	fread(nt_file, sizeof(char), length, file);
	nt_file[length] = '\0';
	fclose(file);

	char* nt_read = NULL;
	int i;
	nt_read = strtok(nt_file, ", \n");

	for (i = 0; nt_read != NULL; i++) {
		strncpy(non_terminal_string[i], nt_read, MAX_SYMBOL_LENGTH);
		nt_read = strtok(NULL, ", \n");
	}
	free(nt_file);
}

int main(int argc, char* argv[]) {

	if (argc < 3) {
		store_error(-1, SYNTACTIC_ERROR, "Run as ./a.out test_case asm_file");
		exit(1);
	}

	setvbuf(stdout, NULL, _IONBF, 0);

	populate_non_terminal_string();
	populate_terminal_string();

	int choice;
	char source_file[MAX_FILE_NAME_LEN];
	strncpy(source_file, argv[1], MAX_FILE_NAME_LEN);
	strncpy(assembly_file, argv[2], MAX_FILE_NAME_LEN);

	FILE* source = fopen(source_file, "r");
	if (source == NULL) {
		printf("Error opening file\n");
	}

	while (true) {
		print_menu();
		scanf("%d", &choice);
		printf("\n");

		switch (choice) {
		case 0:
		{
			exit(0);
		}
		break;

		case 1:
		{
			// lexer_init(source);
			tokenize_source_file(source);
		}
		break;

		case 2:
		{
			// lexer_init(source);
			parser_init();

			FILE* fptr = fopen("grammar.txt", "r");
			if (fptr == NULL)
			{
				perror("fopen");
			}
			produce_grammar(fptr);

			populate_first_sets();

			populate_follow_sets();

			createParseTable();
			// print_parse_table();

			tree_node* ptr = parseInputSourceCode(source);

			if (ptr == NULL)
			{
				printf("Empty parse tree\n");
			}

			print_parse_tree(ptr);
			free_grammar();
			fclose(fptr);

		}
		break;

		case 3:
		
		{

			// lexer_init(source);
			parser_init();

			FILE* fptr = fopen("grammar.txt", "r");
			if (fptr == NULL)
			{
				perror("fopen");
			}
			produce_grammar(fptr);

			populate_first_sets();

			populate_follow_sets();

			createParseTable();

			num_tree_nodes = 0;
			tree_node* ptr = parseInputSourceCode(source);
			int num_pt_nodes = num_tree_nodes;

			num_tree_nodes = 0;
			fclose(fptr);

			tree_node* ast_tree = construct_ast(ptr);
			// ptr->visited = false;
			traverse_ast(ast_tree);
			int num_ast_nodes = num_tree_nodes;

			printf("Parse tree number of nodes = %d\n", num_pt_nodes);

			unsigned long mem_pt = num_pt_nodes * sizeof(tree_node);
			printf("Allocated memory = %lu\n", mem_pt);

			printf("AST number of nodes = %d\n", num_ast_nodes);

			unsigned long mem_ast = num_ast_nodes * sizeof(tree_node);
			printf("Allocated memory = %lu\n", mem_ast);

			double comp_perc = ((mem_pt - mem_ast + 0.0) / (mem_pt + 0.0)) * 100;
			printf("Compression percentage = %lf\n", comp_perc);
		}
		break;

		
		default:
		{
			exit(0);
		}
		
		} // end of switch
	}
	fclose(source);
} // end of main